# -*- coding: utf-8 -*-
from PySide6 import QtWidgets
from PySide6.QtWidgets import QWidget
from PySide6 import QtCore
from PySide6.QtCore import Qt, QUrl, QSize, QTimer, QPoint, QRect
from PySide6.QtGui import QIcon, QCursor
from PySide6.QtMultimedia import QMediaPlayer, QAudioOutput
from typing import Optional
from search import format_ms
from player_widget_ui import Ui_PlayerWidget
from PySide6.QtMultimediaWidgets import QVideoWidget
import os

try:
    import resources_rc  # generated by pyside6-rcc from resources.qrc
except Exception:
    # resource module may not exist during development
    pass

class PlayerWidget(QWidget, Ui_PlayerWidget):
    """PlayerWidget built from .ui; wiring lives here."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi(self)

        self._pending_position_ms: Optional[int] = None
        self._slider_is_dragging = False
        self._is_fullscreen = False
        
        # 控制条自动隐藏相关
        self._controls_hidden = False
        self._hide_timer = QTimer(self)
        self._hide_timer.setSingleShot(True)
        self._hide_timer.timeout.connect(self._hide_controls)
        self._HIDE_DELAY = 3000  # 3秒后自动隐藏
        
        # 保存控制条原始高度用于自动隐藏
        self._original_controls_height = self.controlsContainer.height()

        # configure UI defaults similar to previous implementation
        try:
            self.videoWidget.setMinimumHeight(240)
        except Exception:
            pass

        self.playbackSlider.setRange(0, 1000)
        self.playbackSlider.setEnabled(False)
        
        # 设置进度条样式使其符合Fluent风格
        self.playbackSlider.setStyleSheet("""
            QSlider::groove:horizontal {
                background-color: #DADCE0;
                height: 6px;
                border-radius: 3px;
            }
            QSlider::handle:horizontal {
                width: 20px;
                height: 20px;
                border-radius: 10px;
                background-color: #FFFFFF;
                border: 2px solid #4285F4;
                margin-top: -7px;
                margin-bottom: -7px;
            }
            QSlider::handle:horizontal:hover {
                background-color: #4285F4;
            }
            QSlider::sub-page:horizontal {
                background-color: #4285F4;
                height: 6px;
                border-radius: 3px;
            }
        """)

        # populate rate selector
        for r in [0.5, 1.0, 1.25, 1.5, 2.0]:
            self.rateSelector.addItem(f"{r}x", r)
        try:
            self.rateSelector.setCurrentIndex(1)
        except Exception:
            pass

        self._icon_play = None
        self._icon_pause = None
        self._icon_stop = None
        # 设置按钮样式使其符合Fluent风格
        self.playButton.setStyleSheet("color: #202124; font-size: 14px;")
        self.stopButton.setStyleSheet("color: #202124; font-size: 14px;")
         
        try:
            # 设置全屏按钮样式
            self.fullscreenButton.setText('⛶')
            self.fullscreenButton.setStyleSheet("color: #202124; font-size: 14px;")
        except Exception:
            pass

        # connect signals
        try:
            # use a single play button as toggle (hide pause button from main window)
            self.playButton.clicked.connect(self._on_play_toggle)
            # keep pause/stop handlers for compatibility
            # self.pauseButton.clicked.connect(self._on_pause_clicked)
            self.stopButton.clicked.connect(self._on_stop_clicked)

            self.playbackSlider.sliderPressed.connect(self._on_slider_pressed)
            self.playbackSlider.sliderReleased.connect(self._on_slider_released)
            self.playbackSlider.sliderMoved.connect(self._on_slider_moved)

            self.rateSelector.currentIndexChanged.connect(self._on_rate_changed)
            self.fullscreenButton.clicked.connect(self._on_fullscreen_clicked)
        except Exception:
            pass

        # Media
        self.player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.player.setAudioOutput(self.audio_output)
        try:
            self.player.setVideoOutput(self.videoWidget)
        except Exception:
            pass

        # connect player signals
        try:
            self.player.positionChanged.connect(self._on_player_position_changed)
            self.player.durationChanged.connect(self._on_player_duration_changed)
            self.player.mediaStatusChanged.connect(self._on_media_status_changed)
            try:
                self.player.bufferStatusChanged.connect(self._on_buffer_status_changed)
            except Exception:
                pass
            # update play button when playback state changes
            try:
                self.player.playbackStateChanged.connect(self._on_playback_state_changed)
            except Exception:
                # some versions may use different signal name
                try:
                    self.player.stateChanged.connect(self._on_playback_state_changed)
                except Exception:
                    pass
        except Exception:
            pass

        # 设置所有按钮和控制元素的样式使其符合Fluent风格
        try:
            # 设置按钮样式
            for btn in (self.playButton, self.stopButton, self.fullscreenButton):
                btn.setFlat(True)
                btn.setAutoDefault(False)
                btn.setDefault(False)
                btn.setStyleSheet("background-color: transparent; color: #202124; border: none; padding: 8px 12px; font-size: 14px;")
                btn.setFocusPolicy(Qt.NoFocus)
            
            # 设置倍速选择器样式
            self.rateSelector.setStyleSheet("""
                QComboBox {
                    background-color: #FFFFFF;
                    color: #202124;
                    border: 1px solid #DADCE0;
                    border-radius: 4px;
                    padding: 4px 24px 4px 8px;
                    font-size: 12px;
                    min-width: 50px;
                    max-width: 80px;
                }
                QComboBox::drop-down {
                    subcontrol-origin: padding;
                    subcontrol-position: top right;
                    width: 20px;
                    border-left: 1px solid #DADCE0;
                    border-right: none;
                    border-top: none;
                    border-bottom: none;
                }
                QComboBox::down-arrow {
                    image: url(resources/dropdown_arrow.svg);
                    width: 10px;
                    height: 10px;
                }
                QComboBox:hover {
                    border-color: #90CAF9;
                }
                QComboBox:focus {
                    border-color: #4285F4;
                    outline: none;
                }
                QComboBox QAbstractItemView {
                    background-color: #FFFFFF;
                    border: 1px solid #DADCE0;
                    border-radius: 4px;
                    padding: 0;
                    selection-background-color: #E3F2FD;
                    selection-color: #202124;
                }
                QComboBox QAbstractItemView::item {
                    padding: 8px 12px;
                }
            """)
        except Exception:
            pass
        
        # 设置时间标签样式使其符合Fluent风格
        try:
            self.playbackTimeLabel.setStyleSheet("color: #202124; font-size: 13px; padding: 0 12px;")
        except Exception:
            pass
        
        # 安装事件过滤器，用于检测鼠标移动
        self.videoWidget.installEventFilter(self)
        self.controlsContainer.installEventFilter(self)
        
        # 进度条事件处理，防止自动隐藏
        self.playbackSlider.installEventFilter(self)
        
        # 启动自动隐藏定时器
        self._start_hide_timer()

    # Public API
    def play_file(self, path: str):
        url = QUrl.fromLocalFile(path)
        self.player.setSource(url)
        self.player.play()

    def play_at(self, path: str, position_ms: int):
        try:
            self._pending_position_ms = int(position_ms)
        except Exception:
            self._pending_position_ms = None
        url = QUrl.fromLocalFile(path)
        self.player.setSource(url)
        self.player.play()
    
    def play(self, path: str, position_ms: int):
        """兼容方法，用于处理来自搜索结果卡片的点击事件"""
        self.play_at(path, position_ms)

    def set_rate(self, rate: float):
        try:
            self.player.setPlaybackRate(rate)
        except Exception:
            try:
                self.player.setRate(rate)
            except Exception:
                pass

    # UI handlers
    def _on_play_toggle(self):
        try:
            # toggle play/pause
            if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
                self.player.pause()
            else:
                self.player.play()
        except Exception:
            try:
                # fall back to older API
                if self.player.state() == QMediaPlayer.PlayingState:
                    self.player.pause()
                else:
                    self.player.play()
            except Exception:
                pass

    def _on_play_clicked(self):
        try:
            self.player.play()
        
        
        except Exception as errors:
            print('Playback error:', errors)
            pass

    def _on_pause_clicked(self):
        try:
            self.player.pause()
        except Exception:
            pass

    def _on_stop_clicked(self):
        try:
            self.player.stop()
        except Exception:
            pass

    # Internal handlers (reusing previous logic)
    def _on_media_status_changed(self, status):
        try:
            if status == QMediaPlayer.MediaStatus.LoadedMedia and self._pending_position_ms is not None:
                try:
                    self.player.setPosition(int(self._pending_position_ms))
                except Exception:
                    pass
                self._pending_position_ms = None

            try:
                if status in (QMediaPlayer.MediaStatus.LoadedMedia, QMediaPlayer.MediaStatus.BufferedMedia, QMediaPlayer.MediaStatus.Buffered):
                    self.playbackSlider.setEnabled(True)
                else:
                    if status == QMediaPlayer.MediaStatus.NoMedia:
                        self.playbackSlider.setEnabled(False)
            except Exception:
                pass
        except Exception:
            pass

    def _on_player_position_changed(self, pos_ms: int):
        try:
            dur = self.player.duration() or 0
            self.playbackTimeLabel.setText(f"{format_ms(int(pos_ms))} / {format_ms(int(dur))}")
            if dur > 0 and not self._slider_is_dragging:
                val = int((pos_ms / dur) * 1000)
                self.playbackSlider.setValue(max(0, min(val, 1000)))
        except Exception:
            pass

    def _on_player_duration_changed(self, dur_ms: int):
        try:
            pos = self.player.position() or 0
            self.playbackTimeLabel.setText(f"{format_ms(int(pos))} / {format_ms(int(dur_ms))}")
            try:
                if dur_ms > 0:
                    self.playbackSlider.setEnabled(True)
                else:
                    self.playbackSlider.setEnabled(False)
            except Exception:
                pass
        except Exception:
            pass

    def _on_buffer_status_changed(self, percent: int):
        try:
            self.bufferLabel.setText(f"Buffer: {int(percent)}%")
        except Exception:
            pass

    def _on_rate_changed(self, idx: int):
        try:
            rate = float(self.rateSelector.currentData())
            self.set_rate(rate)
        except Exception:
            pass

    # Slider interactions
    def _on_slider_pressed(self):
        self._slider_is_dragging = True

    def _on_slider_released(self):
        try:
            self._slider_is_dragging = False
            val = self.playbackSlider.value()
            dur = self.player.duration() or 0
            if dur > 0:
                pos = int((val / 1000.0) * dur)
                self.player.setPosition(pos)
        except Exception:
            pass

    def _on_slider_moved(self, value: int):
        try:
            dur = self.player.duration() or 0
            if dur > 0:
                pos = int((value / 1000.0) * dur)
                self.playbackTimeLabel.setText(f"{format_ms(pos)} / {format_ms(int(dur))}")
        except Exception:
            pass

    def _on_playback_state_changed(self, state):
        try:
            # Normalize state handling for different Qt versions
            if isinstance(state, QMediaPlayer.PlaybackState):
                playing = (state == QMediaPlayer.PlaybackState.PlayingState)
            else:
                # older API: state may be an int or enum mapping to QMediaPlayer.PlayingState
                try:
                    playing = (state == QMediaPlayer.PlayingState)
                except Exception:
                    playing = False

            if playing:
                try:
                    #self.playButton.setText(self._icon_pause.)
                    self.playButton.setIcon(self._icon_pause)
                except Exception:
                    pass
            else:
                try:
                    self.playButton.setIcon(self._icon_play)
                    # self.playButton.setText('▶')
                except Exception:
                    pass
        except Exception:
            pass

    def _on_fullscreen_clicked(self):
        try:
            if not self._is_fullscreen:
                # 保存视频部件的原始尺寸和状态
                self._original_video_size = self.videoWidget.size()
                self._original_video_min_height = self.videoWidget.minimumHeight()
                
                # Enter fullscreen mode for video widget only
                self.videoWidget.setParent(None)  # 从当前布局中移除
                self.videoWidget.showFullScreen()
                # 使用图标而不是文字
                self.fullscreenButton.setText('⛶')
                # 全屏时隐藏其他控制元素
                self.playbackSlider.hide()
                self.playbackTimeLabel.hide()
                self.bufferLabel.hide()
                self.controlsContainer.hide()
                
                # 安装事件过滤器以捕获ESC键
                self.videoWidget.installEventFilter(self)
            else:
                # Exit fullscreen mode
                self.videoWidget.showNormal()
                # 将视频部件重新添加回布局
                self.verticalLayout.insertWidget(0, self.videoWidget)
                # 使用图标而不是文字
                self.fullscreenButton.setText('⛶')
                # 恢复视频部件的原始尺寸和状态
                self.videoWidget.setMinimumHeight(self._original_video_min_height)
                self.videoWidget.resize(self._original_video_size)
                # 恢复控制元素显示
                self.playbackSlider.show()
                self.playbackTimeLabel.show()
                self.bufferLabel.show()
                self.controlsContainer.show()
                
                # 移除事件过滤器
                self.videoWidget.removeEventFilter(self)
            self._is_fullscreen = not self._is_fullscreen
            
            # 全屏切换时重置控制条状态
            self._show_controls()
            self._start_hide_timer()
        except Exception as e:
            print('Fullscreen error:', e)
            pass

    def set_icons(self, play_icon: QIcon = None, pause_icon: QIcon = None, stop_icon: QIcon = None):
        """Allow host application to provide QIcons (from QRC or filesystem).
        This avoids calling QIcon(':/...') inside the widget and keeps resource loading centralized.
        Also updates any internal toolbar buttons if already created.
        """
        try:
            if play_icon is not None and not play_icon.isNull():
                self._icon_play = play_icon
                try:
                    # update embedded buttons
                    self.playButton.setIcon(self._icon_play)
                    self.playButton.setIconSize(QSize(24, 24))  # 增大图标尺寸以适应按钮大小
                    try:
                        self.playButton.setText('')
                    except Exception:
                        pass
                except Exception:
                    pass
                try:
                    # update toolbar button if exists
                    if hasattr(self, '_tb_play'):
                        self._tb_play.setIcon(self._icon_play)
                        self._tb_play.setIconSize(QSize(24, 24))
                        self._tb_play.setVisible(True)
                except Exception:
                    pass
            if pause_icon is not None and not pause_icon.isNull():
                self._icon_pause = pause_icon
                try:
                    # self.pauseButton.setIcon(self._icon_pause)
                    # self.pauseButton.setIconSize(QSize(24, 24))  # 增大图标尺寸以适应按钮大小
                    # try:
                    #     self.pauseButton.setText('')
                    # except Exception:
                    #     pass
                    pass
                except Exception:
                    pass
                try:
                    if hasattr(self, '_tb_pause'):
                        self._tb_pause.setIcon(self._icon_pause)
                        self._tb_pause.setIconSize(QSize(22, 22))
                        self._tb_pause.setVisible(True)
                except Exception:
                    pass
            if stop_icon is not None and not stop_icon.isNull():
                self._icon_stop = stop_icon
                try:
                    self.stopButton.setIcon(self._icon_stop)
                    self.stopButton.setIconSize(QSize(24, 24))  # 增大图标尺寸以适应按钮大小
                    try:
                        self.stopButton.setText('')
                    except Exception:
                        pass
                except Exception:
                    pass
                try:
                    if hasattr(self, '_tb_stop'):
                        self._tb_stop.setIcon(self._icon_stop)
                        self._tb_stop.setIconSize(QSize(22, 22))
                        self._tb_stop.setVisible(True)
                except Exception:
                    pass
        except Exception:
            pass
    
    def eventFilter(self, obj, event):
        """事件过滤器，用于检测鼠标移动和控制自动隐藏"""
        if event.type() == QtCore.QEvent.MouseMove:
            # 鼠标在视频区域或控制区域移动时显示控制条
            if obj == self.videoWidget or obj == self.controlsContainer or obj == self.playbackSlider:
                self._show_controls()
                self._start_hide_timer()
                return True
        elif event.type() == QtCore.QEvent.MouseButtonDblClick:
            # 鼠标双击切换全屏模式
            if obj == self.videoWidget:
                self._on_fullscreen_clicked()
                return True
        elif event.type() == QtCore.QEvent.MouseButtonPress:
            # 鼠标点击时显示控制条
            if obj == self.videoWidget or obj == self.controlsContainer or obj == self.playbackSlider:
                self._show_controls()
                self._start_hide_timer()
                return True
        elif event.type() == QtCore.QEvent.KeyPress:
            # ESC键退出全屏模式
            if obj == self.videoWidget and self._is_fullscreen and event.key() == QtCore.Qt.Key_Escape:
                self._on_fullscreen_clicked()
                return True
        return super().eventFilter(obj, event)
    
    def _start_hide_timer(self):
        """启动自动隐藏定时器"""
        try:
            # 只有在播放状态下才自动隐藏
            if hasattr(self, 'player'):
                try:
                    if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
                        self._hide_timer.start(self._HIDE_DELAY)
                    else:
                        self._hide_timer.stop()
                except Exception:
                    # 兼容旧版本API
                    if self.player.state() == QMediaPlayer.PlayingState:
                        self._hide_timer.start(self._HIDE_DELAY)
                    else:
                        self._hide_timer.stop()
        except Exception:
            pass
    
    def _show_controls(self):
        """显示控制条"""
        if self._controls_hidden:
            try:
                # 恢复控制条高度
                self.controlsContainer.resize(self.controlsContainer.width(), self._original_controls_height)
                self.controlsContainer.show()
                self._controls_hidden = False
            except Exception:
                pass
    
    def keyPressEvent(self, event):
        """处理键盘事件，支持ESC键退出全屏"""
        if event.key() == QtCore.Qt.Key_Escape and self._is_fullscreen:
            self._on_fullscreen_clicked()
    
    def _hide_controls(self):
        """隐藏控制条"""
        if not self._controls_hidden:
            try:
                # 检查鼠标是否在控制条或进度条上，如果在则不隐藏
                cursor_pos = QCursor.pos()
                video_rect = self.videoWidget.mapToGlobal(self.videoWidget.rect())
                controls_rect = self.controlsContainer.mapToGlobal(self.controlsContainer.rect())
                
                # 如果鼠标在视频区域底部（控制条位置），则不隐藏
                if controls_rect.contains(cursor_pos) or \
                   (video_rect.contains(cursor_pos) and cursor_pos.y() >= video_rect.bottom() - 100):
                    self._start_hide_timer()
                    return
                    
                # 隐藏控制条
                self.controlsContainer.resize(self.controlsContainer.width(), 0)
                self.controlsContainer.hide()
                self._controls_hidden = True
            except Exception:
                pass