# -*- coding: utf-8 -*-
from PySide6 import QtWidgets
from PySide6.QtWidgets import QWidget
from PySide6 import QtCore
from PySide6.QtCore import Qt, QUrl, QSize, QTimer, QPoint, QRect
from PySide6.QtGui import QIcon, QCursor
from PySide6.QtMultimedia import QMediaPlayer, QAudioOutput
from typing import Optional
from search import format_ms
from player_widget_ui import Ui_PlayerWidget
from PySide6.QtMultimediaWidgets import QVideoWidget
import os

try:
    import resources_rc  # generated by pyside6-rcc from resources.qrc
except Exception:
    # resource module may not exist during development
    pass

class PlayerWidget(QWidget, Ui_PlayerWidget):
    """PlayerWidget built from .ui; wiring lives here."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi(self)

        self._pending_position_ms: Optional[int] = None
        self._slider_is_dragging = False
        self._is_fullscreen = False
        
        # 控制条自动隐藏相关
        self._controls_hidden = False
        self._hide_timer = QTimer(self)
        self._hide_timer.setSingleShot(True)
        self._hide_timer.timeout.connect(self._hide_controls)
        self._HIDE_DELAY = 3000  # 3秒后自动隐藏
        
        # 保存控制条原始高度用于自动隐藏
        self._original_controls_height = self.controlsContainer.height()

        # configure UI defaults similar to previous implementation
        try:
            self.videoWidget.setMinimumHeight(240)
        except Exception:
            pass

        self.playbackSlider.setRange(0, 1000)
        self.playbackSlider.setEnabled(False)
        
        # 设置进度条样式使其更紧凑
        self.playbackSlider.setStyleSheet("""
            QSlider::groove:horizontal {
                background-color: rgba(255, 255, 255, 0.3);
                height: 4px;
                border-radius: 2px;
            }
            QSlider::handle:horizontal {
                background-color: white;
                width: 12px;
                height: 12px;
                border-radius: 6px;
                margin: -4px 0;
            }
            QSlider::sub-page:horizontal {
                background-color: #0078d4;
                height: 4px;
                border-radius: 2px;
            }
        """)

        # populate rate selector
        for r in [0.5, 1.0, 1.25, 1.5, 2.0]:
            self.rateSelector.addItem(f"{r}x", r)
        try:
            self.rateSelector.setCurrentIndex(1)
        except Exception:
            pass

        self._icon_play = None
        self._icon_pause = None
        self._icon_stop = None
        #self.playButton.setText('▶')
        self.playButton.setStyleSheet("color: white;")
        #self.stopButton.setText('■')
        self.stopButton.setStyleSheet("color: white;")
         
        
        try:
            # 设置全屏按钮样式
            self.fullscreenButton.setText('⛶')
            self.fullscreenButton.setStyleSheet("color: white;")
        except Exception:
            pass

        # 隐藏暂停按钮，使用播放按钮作为切换
        # self.pauseButton.hide()

        # connect signals
        try:
            # use a single play button as toggle (hide pause button from main window)
            self.playButton.clicked.connect(self._on_play_toggle)
            # keep pause/stop handlers for compatibility
            # self.pauseButton.clicked.connect(self._on_pause_clicked)
            self.stopButton.clicked.connect(self._on_stop_clicked)

            self.playbackSlider.sliderPressed.connect(self._on_slider_pressed)
            self.playbackSlider.sliderReleased.connect(self._on_slider_released)
            self.playbackSlider.sliderMoved.connect(self._on_slider_moved)

            self.rateSelector.currentIndexChanged.connect(self._on_rate_changed)
            self.fullscreenButton.clicked.connect(self._on_fullscreen_clicked)
        except Exception:
            pass

        # Media
        self.player = QMediaPlayer()
        self.audio_output = QAudioOutput()
        self.player.setAudioOutput(self.audio_output)
        try:
            self.player.setVideoOutput(self.videoWidget)
        except Exception:
            pass

        # connect player signals
        try:
            self.player.positionChanged.connect(self._on_player_position_changed)
            self.player.durationChanged.connect(self._on_player_duration_changed)
            self.player.mediaStatusChanged.connect(self._on_media_status_changed)
            try:
                self.player.bufferStatusChanged.connect(self._on_buffer_status_changed)
            except Exception:
                pass
            # update play button when playback state changes
            try:
                self.player.playbackStateChanged.connect(self._on_playback_state_changed)
            except Exception:
                # some versions may use different signal name
                try:
                    self.player.stateChanged.connect(self._on_playback_state_changed)
                except Exception:
                    pass
        except Exception:
            pass

        # 设置所有按钮的样式
        try:
            for btn in (self.playButton, self.stopButton, self.fullscreenButton):
                btn.setFlat(True)
                btn.setAutoDefault(False)
                btn.setDefault(False)
                btn.setStyleSheet("background-color: transparent; color: white; border: none;")
                btn.setFocusPolicy(Qt.NoFocus)
        except Exception:
            pass
        
        # 设置时间标签样式
        try:
            self.playbackTimeLabel.setStyleSheet("color: white; font-size: 11px;")
        except Exception:
            pass
        
        # 安装事件过滤器，用于检测鼠标移动
        self.videoWidget.installEventFilter(self)
        self.controlsContainer.installEventFilter(self)
        
        # 进度条事件处理，防止自动隐藏
        self.playbackSlider.installEventFilter(self)
        
        # 启动自动隐藏定时器
        self._start_hide_timer()

    # Public API
    def play_file(self, path: str):
        url = QUrl.fromLocalFile(path)
        self.player.setSource(url)
        self.player.play()

    def play_at(self, path: str, position_ms: int):
        try:
            self._pending_position_ms = int(position_ms)
        except Exception:
            self._pending_position_ms = None
        url = QUrl.fromLocalFile(path)
        self.player.setSource(url)
        self.player.play()
    
    def play(self, path: str, position_ms: int):
        """兼容方法，用于处理来自搜索结果卡片的点击事件"""
        self.play_at(path, position_ms)

    def set_rate(self, rate: float):
        try:
            self.player.setPlaybackRate(rate)
        except Exception:
            try:
                self.player.setRate(rate)
            except Exception:
                pass

    # UI handlers
    def _on_play_toggle(self):
        try:
            # toggle play/pause
            if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
                self.player.pause()
            else:
                self.player.play()
        except Exception:
            try:
                # fall back to older API
                if self.player.state() == QMediaPlayer.PlayingState:
                    self.player.pause()
                else:
                    self.player.play()
            except Exception:
                pass

    def _on_play_clicked(self):
        try:
            self.player.play()
        
        
        except Exception as errors:
            print('Playback error:', errors)
            pass

    def _on_pause_clicked(self):
        try:
            self.player.pause()
        except Exception:
            pass

    def _on_stop_clicked(self):
        try:
            self.player.stop()
        except Exception:
            pass

    # Internal handlers (reusing previous logic)
    def _on_media_status_changed(self, status):
        try:
            if status == QMediaPlayer.MediaStatus.LoadedMedia and self._pending_position_ms is not None:
                try:
                    self.player.setPosition(int(self._pending_position_ms))
                except Exception:
                    pass
                self._pending_position_ms = None

            try:
                if status in (QMediaPlayer.MediaStatus.LoadedMedia, QMediaPlayer.MediaStatus.BufferedMedia, QMediaPlayer.MediaStatus.Buffered):
                    self.playbackSlider.setEnabled(True)
                else:
                    if status == QMediaPlayer.MediaStatus.NoMedia:
                        self.playbackSlider.setEnabled(False)
            except Exception:
                pass
        except Exception:
            pass

    def _on_player_position_changed(self, pos_ms: int):
        try:
            dur = self.player.duration() or 0
            self.playbackTimeLabel.setText(f"{format_ms(int(pos_ms))} / {format_ms(int(dur))}")
            if dur > 0 and not self._slider_is_dragging:
                val = int((pos_ms / dur) * 1000)
                self.playbackSlider.setValue(max(0, min(val, 1000)))
        except Exception:
            pass

    def _on_player_duration_changed(self, dur_ms: int):
        try:
            pos = self.player.position() or 0
            self.playbackTimeLabel.setText(f"{format_ms(int(pos))} / {format_ms(int(dur_ms))}")
            try:
                if dur_ms > 0:
                    self.playbackSlider.setEnabled(True)
                else:
                    self.playbackSlider.setEnabled(False)
            except Exception:
                pass
        except Exception:
            pass

    def _on_buffer_status_changed(self, percent: int):
        try:
            self.bufferLabel.setText(f"Buffer: {int(percent)}%")
        except Exception:
            pass

    def _on_rate_changed(self, idx: int):
        try:
            rate = float(self.rateSelector.currentData())
            self.set_rate(rate)
        except Exception:
            pass

    # Slider interactions
    def _on_slider_pressed(self):
        self._slider_is_dragging = True

    def _on_slider_released(self):
        try:
            self._slider_is_dragging = False
            val = self.playbackSlider.value()
            dur = self.player.duration() or 0
            if dur > 0:
                pos = int((val / 1000.0) * dur)
                self.player.setPosition(pos)
        except Exception:
            pass

    def _on_slider_moved(self, value: int):
        try:
            dur = self.player.duration() or 0
            if dur > 0:
                pos = int((value / 1000.0) * dur)
                self.playbackTimeLabel.setText(f"{format_ms(pos)} / {format_ms(int(dur))}")
        except Exception:
            pass

    def _on_playback_state_changed(self, state):
        try:
            # Normalize state handling for different Qt versions
            if isinstance(state, QMediaPlayer.PlaybackState):
                playing = (state == QMediaPlayer.PlaybackState.PlayingState)
            else:
                # older API: state may be an int or enum mapping to QMediaPlayer.PlayingState
                try:
                    playing = (state == QMediaPlayer.PlayingState)
                except Exception:
                    playing = False

            if playing:
                try:
                    #self.playButton.setText(self._icon_pause.)
                    self.playButton.setIcon(self._icon_pause)
                except Exception:
                    pass
            else:
                try:
                    self.playButton.setIcon(self._icon_play)
                    # self.playButton.setText('▶')
                except Exception:
                    pass
        except Exception:
            pass

    def _on_fullscreen_clicked(self):
        try:
            if not self._is_fullscreen:
                # Enter fullscreen mode
                self.videoWidget.showFullScreen()
                self.fullscreenButton.setText('Exit Fullscreen')
            else:
                # Exit fullscreen mode
                self.videoWidget.showNormal()
                self.fullscreenButton.setText('Fullscreen')
            self._is_fullscreen = not self._is_fullscreen
            
            # 全屏切换时重置控制条状态
            self._show_controls()
            self._start_hide_timer()
        except Exception as e:
            print('Fullscreen error:', e)
            pass

    def set_icons(self, play_icon: QIcon = None, pause_icon: QIcon = None, stop_icon: QIcon = None):
        """Allow host application to provide QIcons (from QRC or filesystem).
        This avoids calling QIcon(':/...') inside the widget and keeps resource loading centralized.
        Also updates any internal toolbar buttons if already created.
        """
        try:
            if play_icon is not None and not play_icon.isNull():
                self._icon_play = play_icon
                try:
                    # update embedded buttons
                    self.playButton.setIcon(self._icon_play)
                    self.playButton.setIconSize(QSize(24, 24))  # 增大图标尺寸以适应按钮大小
                    try:
                        self.playButton.setText('')
                    except Exception:
                        pass
                except Exception:
                    pass
                try:
                    # update toolbar button if exists
                    if hasattr(self, '_tb_play'):
                        self._tb_play.setIcon(self._icon_play)
                        self._tb_play.setIconSize(QSize(24, 24))
                        self._tb_play.setVisible(True)
                except Exception:
                    pass
            if pause_icon is not None and not pause_icon.isNull():
                self._icon_pause = pause_icon
                try:
                    # self.pauseButton.setIcon(self._icon_pause)
                    # self.pauseButton.setIconSize(QSize(24, 24))  # 增大图标尺寸以适应按钮大小
                    # try:
                    #     self.pauseButton.setText('')
                    # except Exception:
                    #     pass
                    pass
                except Exception:
                    pass
                try:
                    if hasattr(self, '_tb_pause'):
                        self._tb_pause.setIcon(self._icon_pause)
                        self._tb_pause.setIconSize(QSize(22, 22))
                        self._tb_pause.setVisible(True)
                except Exception:
                    pass
            if stop_icon is not None and not stop_icon.isNull():
                self._icon_stop = stop_icon
                try:
                    self.stopButton.setIcon(self._icon_stop)
                    self.stopButton.setIconSize(QSize(24, 24))  # 增大图标尺寸以适应按钮大小
                    try:
                        self.stopButton.setText('')
                    except Exception:
                        pass
                except Exception:
                    pass
                try:
                    if hasattr(self, '_tb_stop'):
                        self._tb_stop.setIcon(self._icon_stop)
                        self._tb_stop.setIconSize(QSize(22, 22))
                        self._tb_stop.setVisible(True)
                except Exception:
                    pass
        except Exception:
            pass
    
    def eventFilter(self, obj, event):
        """事件过滤器，用于检测鼠标移动和控制自动隐藏"""
        if event.type() == QtCore.QEvent.MouseMove:
            # 鼠标在视频区域或控制区域移动时显示控制条
            if obj == self.videoWidget or obj == self.controlsContainer or obj == self.playbackSlider:
                self._show_controls()
                self._start_hide_timer()
                return True
        elif event.type() == QtCore.QEvent.MouseButtonPress:
            # 鼠标点击时显示控制条
            if obj == self.videoWidget or obj == self.controlsContainer or obj == self.playbackSlider:
                self._show_controls()
                self._start_hide_timer()
                return True
        return super().eventFilter(obj, event)
    
    def _start_hide_timer(self):
        """启动自动隐藏定时器"""
        try:
            # 只有在播放状态下才自动隐藏
            if hasattr(self, 'player'):
                try:
                    if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
                        self._hide_timer.start(self._HIDE_DELAY)
                    else:
                        self._hide_timer.stop()
                except Exception:
                    # 兼容旧版本API
                    if self.player.state() == QMediaPlayer.PlayingState:
                        self._hide_timer.start(self._HIDE_DELAY)
                    else:
                        self._hide_timer.stop()
        except Exception:
            pass
    
    def _show_controls(self):
        """显示控制条"""
        if self._controls_hidden:
            try:
                # 恢复控制条高度
                self.controlsContainer.resize(self.controlsContainer.width(), self._original_controls_height)
                self.controlsContainer.show()
                self._controls_hidden = False
            except Exception:
                pass
    
    def _hide_controls(self):
        """隐藏控制条"""
        if not self._controls_hidden:
            try:
                # 检查鼠标是否在控制条或进度条上，如果在则不隐藏
                cursor_pos = QCursor.pos()
                video_rect = self.videoWidget.mapToGlobal(self.videoWidget.rect())
                controls_rect = self.controlsContainer.mapToGlobal(self.controlsContainer.rect())
                
                # 如果鼠标在视频区域底部（控制条位置），则不隐藏
                if controls_rect.contains(cursor_pos) or \
                   (video_rect.contains(cursor_pos) and cursor_pos.y() >= video_rect.bottom() - 100):
                    self._start_hide_timer()
                    return
                    
                # 隐藏控制条
                self.controlsContainer.resize(self.controlsContainer.width(), 0)
                self.controlsContainer.hide()
                self._controls_hidden = True
            except Exception:
                pass